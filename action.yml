name: 'Skyhook Git Sync and Commit'
description: 'Safely sync, commit, and push changes with automatic rebase and retry logic'
author: 'Skyhook'

branding:
  icon: 'git-commit'
  color: 'purple'

inputs:
  path:
    description: 'Working directory for git operations'
    required: false
    default: '.'
  commit_message:
    description: 'Commit message'
    required: true
  commit_user_name:
    description: 'Git committer name'
    required: false
    default: 'github-actions[bot]'
  commit_user_email:
    description: 'Git committer email'
    required: false
    default: '41898282+github-actions[bot]@users.noreply.github.com'
  file_pattern:
    description: 'Files to stage for commit (e.g., ".", "*.yml", "path/to/files/*")'
    required: false
    default: '.'
  max_retries:
    description: 'Maximum number of push retry attempts (handles concurrent pushes)'
    required: false
    default: '3'

outputs:
  committed:
    description: 'Whether a commit was created (true/false)'
    value: ${{ steps.commit.outputs.committed }}
  commit_sha:
    description: 'SHA of the created commit (empty if no commit)'
    value: ${{ steps.commit.outputs.commit_sha }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -euo pipefail

        if [[ ! -d "${{ inputs.path }}" ]]; then
          echo "::error::Working directory not found: ${{ inputs.path }}"
          exit 1
        fi

        if [[ -z "${{ inputs.commit_message }}" ]]; then
          echo "::error::commit_message is required"
          exit 1
        fi

        # Validate max_retries is a number
        if ! [[ "${{ inputs.max_retries }}" =~ ^[0-9]+$ ]]; then
          echo "::error::max_retries must be a positive integer"
          exit 1
        fi

    - name: Sync and commit changes
      id: commit
      shell: bash
      working-directory: ${{ inputs.path }}
      env:
        COMMIT_MESSAGE: ${{ inputs.commit_message }}
        COMMIT_USER_NAME: ${{ inputs.commit_user_name }}
        COMMIT_USER_EMAIL: ${{ inputs.commit_user_email }}
        FILE_PATTERN: ${{ inputs.file_pattern }}
        MAX_RETRIES: ${{ inputs.max_retries }}
      run: |
        set -euo pipefail
 
        echo "üîÑ Starting git sync and commit process..."

        # Configure git user for this operation only
        git config user.name "$COMMIT_USER_NAME"
        git config user.email "$COMMIT_USER_EMAIL"

        # Stash any uncommitted changes (including untracked files)
        echo "üì¶ Stashing current changes..."
        STASH_RESULT=0
        git stash push -u -m "temp-stashed-changes" || STASH_RESULT=$?

        if [ $STASH_RESULT -ne 0 ]; then
          # Check if it's because there's nothing to stash (expected) or a real error
          if git diff --quiet && git diff --cached --quiet && [ -z "$(git ls-files --others --exclude-standard)" ]; then
            echo "‚ÑπÔ∏è  Nothing to stash"
            STASH_RESULT=0
          else
            echo "::error::Failed to stash changes"
            exit 1
          fi
        fi

        # Pull latest changes with rebase
        echo "‚¨áÔ∏è  Pulling latest changes with rebase..."
        git pull --rebase origin "$(git branch --show-current)"

        # Pop the stash to restore changes (if we stashed anything)
        echo "üìÇ Restoring stashed changes..."
        if [ "$(git stash list | grep -c 'temp-stashed-changes')" -gt 0 ]; then
          if ! git stash pop; then
            echo "‚ö†Ô∏è  Merge conflicts detected during stash pop"

            # Get list of conflicted files
            CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)

            if [ -n "$CONFLICTED_FILES" ]; then
              echo "üîß Resolving conflicts by accepting stashed changes..."

              # For each conflicted file, accept the stashed version
              # In stash pop context: --theirs = stashed changes (what we want)
              RESOLUTION_FAILED=0
              while IFS= read -r file; do
                if [ -n "$file" ]; then
                  echo "  - Resolving: $file"
                  if ! git checkout --theirs "$file"; then
                    echo "::error::Failed to resolve conflict in $file"
                    RESOLUTION_FAILED=1
                    break
                  fi
                fi
              done <<< "$CONFLICTED_FILES"

              if [ $RESOLUTION_FAILED -ne 0 ]; then
                # Drop the stash to clean up
                git stash drop
                exit 1
              fi

              # Drop the stash since we've successfully applied it
              git stash drop

              echo "‚úÖ Conflicts resolved"
            else
              echo "‚ÑπÔ∏è  No actual conflicts found, continuing..."
              # Still need to drop the stash
              git stash drop
            fi
          fi
        else
          echo "‚ÑπÔ∏è  No stash to restore"
        fi

        # Stage files matching the pattern
        echo "‚ûï Staging files matching pattern: $FILE_PATTERN"
        git add $FILE_PATTERN

        # Check if there are changes to commit
        if git diff --cached --quiet; then
          echo "‚ÑπÔ∏è  No changes to commit"
          echo "committed=false" >> $GITHUB_OUTPUT
          echo "commit_sha=" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Safety check: ensure no conflict markers are being committed
        echo "üîç Checking for conflict markers in staged files..."
        if git diff --cached | grep -qE "^\+.*<<<<<<<|^\+.*=======|^\+.*>>>>>>>"; then
          echo "::error::Conflict markers detected in staged files! Aborting commit."
          echo "The following files contain unresolved conflicts:"
          STAGED_FILES=$(git diff --cached --name-only)
          while IFS= read -r file; do
            if [ -n "$file" ] && grep -qE "<<<<<<<|=======|>>>>>>>" "$file" 2>/dev/null; then
              echo "  - $file"
            fi
          done <<< "$STAGED_FILES"
          exit 1
        fi

        # Create commit
        echo "üíæ Creating commit..."
        git commit -m "$COMMIT_MESSAGE"
        COMMIT_SHA=$(git rev-parse HEAD)

        echo "committed=true" >> $GITHUB_OUTPUT
        echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

        # Push with retry logic
        echo "‚¨ÜÔ∏è  Pushing changes..."
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_RETRIES ]; do
          echo "Push attempt $ATTEMPT of $MAX_RETRIES..."

          if git push origin "$(git branch --show-current)"; then
            echo "‚úÖ Successfully pushed changes!"
            exit 0
          fi

          if [ $ATTEMPT -lt $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è  Push failed, rebasing and retrying..."
            # Use theirs strategy to prefer our committed changes over remote changes during rebase
            # In rebase context: theirs = our local commit (what we want to keep)
            if ! git pull --rebase -X theirs origin "$(git branch --show-current)"; then
              echo "::error::Rebase failed during retry despite conflict resolution strategy."
              echo "::error::This indicates a complex conflict that cannot be auto-resolved."

              # Check if we're in a rebase state
              if [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ]; then
                echo "Aborting rebase..."
                git rebase --abort
              fi

              exit 1
            fi
          fi

          ATTEMPT=$((ATTEMPT + 1))
        done

        echo "::error::Failed to push after $MAX_RETRIES attempts"
        exit 1

    - name: Generate summary
      if: always()
      shell: bash
      working-directory: ${{ inputs.path }}
      run: |
        set -euo pipefail

        echo "## üîÑ Git Sync and Commit Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [[ "${{ steps.commit.outcome }}" == "success" ]]; then
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            echo "‚úÖ **Status:** Successfully committed and pushed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìù Commit Details" >> $GITHUB_STEP_SUMMARY
            echo "- **SHA:** \`${{ steps.commit.outputs.commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Message:** ${{ inputs.commit_message }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Author:** ${{ inputs.commit_user_name }} <${{ inputs.commit_user_email }}>" >> $GITHUB_STEP_SUMMARY
            echo "- **Files:** \`${{ inputs.file_pattern }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è  **Status:** No changes to commit" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "‚ùå **Status:** Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the logs above for error details." >> $GITHUB_STEP_SUMMARY
        fi
